{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _extends = Object.assign || function (target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i];\n\n    for (var key in source) {\n      if (Object.prototype.hasOwnProperty.call(source, key)) {\n        target[key] = source[key];\n      }\n    }\n  }\n\n  return target;\n};\n\nvar _createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();\n\nvar _react = require('react');\n\nvar _react2 = _interopRequireDefault(_react);\n\nvar _utils = require('./utils');\n\nvar _SimpleCache = require('./SimpleCache');\n\nvar _SimpleCache2 = _interopRequireDefault(_SimpleCache);\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _possibleConstructorReturn(self, call) {\n  if (!self) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n}\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n}\n\nvar FetchContext = _react2.default.createContext({});\n\nvar Fetch = function (_Component) {\n  _inherits(Fetch, _Component);\n\n  function Fetch() {\n    var _ref;\n\n    var _temp, _this, _ret;\n\n    _classCallCheck(this, Fetch);\n\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return _ret = (_temp = (_this = _possibleConstructorReturn(this, (_ref = Fetch.__proto__ || Object.getPrototypeOf(Fetch)).call.apply(_ref, [this].concat(args))), _this), _this.state = {\n      request: {\n        url: _this.props.url,\n        options: _this.props.options\n      },\n      fetch: _this.fetch.bind(_this),\n      clearData: _this.clearData.bind(_this),\n      loading: _this.props.manual ? null : true\n    }, _this.cache = null, _this.promises = [], _temp), _possibleConstructorReturn(_this, _ret);\n  }\n\n  _createClass(Fetch, [{\n    key: 'getOptions',\n    value: function getOptions(options) {\n      return (0, _utils.isFunction)(options) ? options() : options;\n    }\n  }, {\n    key: 'setCache',\n    value: function setCache(cache) {\n      this.cache = this.props.cache === true ? new _SimpleCache2.default() : (0, _utils.isObject)(this.props.cache) ? this.props.cache : null;\n    }\n  }, {\n    key: 'componentDidMount',\n    value: function componentDidMount() {\n      var _props = this.props,\n          url = _props.url,\n          options = _props.options,\n          manual = _props.manual,\n          onChange = _props.onChange,\n          cache = _props.cache;\n      this.mounted = true;\n      this.setCache(cache);\n\n      if ((0, _utils.isFunction)(onChange)) {\n        onChange(this.state);\n      }\n\n      if (url && !manual) {\n        this.fetch(url, options);\n      }\n    }\n  }, {\n    key: 'componentDidUpdate',\n    value: function componentDidUpdate(prevProps) {\n      var _props2 = this.props,\n          url = _props2.url,\n          options = _props2.options,\n          manual = _props2.manual,\n          cache = _props2.cache;\n\n      if (url && url !== prevProps.url && !manual) {\n        this.fetch(url, options);\n      }\n\n      if (cache !== prevProps.cache) {\n        this.setCache(cache);\n      }\n    }\n  }, {\n    key: 'componentWillUnmount',\n    value: function componentWillUnmount() {\n      this.mounted = false;\n    }\n  }, {\n    key: 'fetch',\n    value: function fetch(url, options, updateOptions) {\n      var _this2 = this;\n\n      var _props3 = this.props,\n          as = _props3.as,\n          cache = _props3.cache;\n\n      if (url == null) {\n        url = this.props.url;\n      }\n\n      options = this.getOptions(options || this.props.options);\n      var request = {\n        url: url,\n        options: options\n      };\n\n      if (this.cache && this.cache.get(url)) {\n        // Restore cached state\n        var promise = this.cache.get(url);\n        promise.then(function (cachedState) {\n          return _this2.update(cachedState, promise, updateOptions);\n        });\n        this.promises.push(promise);\n      } else {\n        this.update({\n          request: request,\n          loading: true\n        }, null, updateOptions);\n\n        var _promise = this.props.fetchFunction(url, options).then(function (response) {\n          var dataPromise = (0, _utils.isFunction)(as) ? as(response) : (0, _utils.isObject)(as) ? (0, _utils.parseBody)(response, as) : as === 'auto' ? (0, _utils.parseBody)(response) : response[as]();\n          return dataPromise.then(function (data) {\n            return {\n              response: response,\n              data: data\n            };\n          }).catch(function (error) {\n            return {\n              response: response,\n              data: error\n            };\n          });\n        }).then(function (_ref2) {\n          var _newState;\n\n          var response = _ref2.response,\n              data = _ref2.data;\n          var newState = (_newState = {\n            request: request,\n            loading: false\n          }, _defineProperty(_newState, response.ok ? 'error' : 'data', undefined), _defineProperty(_newState, response.ok ? 'data' : 'error', data), _defineProperty(_newState, 'response', response), _newState);\n\n          _this2.update(newState, _promise, updateOptions);\n\n          return newState;\n        }).catch(function (error) {\n          // Catch request errors with no response (CORS issues, etc)\n          var newState = {\n            request: request,\n            data: undefined,\n            error: error,\n            loading: false\n          };\n\n          _this2.update(newState, _promise, updateOptions); // Rethrow so not to swallow errors, especially from errors within handlers (children func / onChange)\n\n\n          throw error;\n          return newState;\n        });\n\n        this.promises.push(_promise);\n\n        if (this.cache) {\n          this.cache.set(url, _promise);\n        }\n\n        return _promise;\n      }\n    }\n  }, {\n    key: 'clearData',\n    value: function clearData() {\n      this.setState({\n        data: undefined\n      });\n    }\n  }, {\n    key: 'update',\n    value: function update(nextState, currentPromise) {\n      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n      if (currentPromise) {\n        // Handle (i.e. ignore) promises resolved out of order from requests\n        var index = this.promises.indexOf(currentPromise);\n\n        if (index === -1) {\n          // Ignore update as a later request/promise has already been processed\n          return;\n        } // Remove currently resolved promise and any outstanding promises\n        // (which will cause them to be ignored when they do resolve/reject)\n\n\n        this.promises.splice(0, index + 1);\n      }\n\n      var _props4 = this.props,\n          onChange = _props4.onChange,\n          onDataChange = _props4.onDataChange;\n      var data = undefined;\n\n      if (nextState.data && nextState.data !== this.state.data && (0, _utils.isFunction)(onDataChange)) {\n        data = onDataChange(nextState.data, options.ignorePreviousData ? undefined : this.state.data);\n      }\n\n      if ((0, _utils.isFunction)(onChange)) {\n        // Always call onChange even if unmounted.  Useful for `POST` requests with a redirect\n        onChange(_extends({}, this.state, nextState, data !== undefined && {\n          data: data\n        }));\n      } // Ignore passing state down if no longer mounted\n\n\n      if (this.mounted) {\n        // If `onDataChange` prop returned a value, we use it for data passed down to the children function\n        this.setState(_extends({}, nextState, data !== undefined && {\n          data: data\n        }));\n      }\n    }\n  }, {\n    key: 'render',\n    value: function render() {\n      var children = this.props.children;\n      return _react2.default.createElement(FetchContext.Provider, {\n        value: this.state\n      }, (0, _utils.isFunction)(children) ? _react2.default.createElement(FetchContext.Consumer, null, children) : children);\n    }\n  }]);\n\n  return Fetch;\n}(_react.Component);\n\nFetch.defaultProps = {\n  as: 'auto',\n  fetchFunction: function fetchFunction(url, options) {\n    return fetch(url, options);\n  }\n};\nFetch.Consumer = FetchContext.Consumer;\nexports.default = Fetch;","map":null,"metadata":{},"sourceType":"script"}